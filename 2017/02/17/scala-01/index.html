<!DOCTYPE html>
<html lang>
  <head><meta name="generator" content="Hexo 3.9.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="description" content="scala 学习 01 基本语法">




  <meta name="keywords" content="scala,">





  <link rel="alternate" href="/default" title="acyouzi">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1">



<link rel="canonical" href="http://acyouzi.com/2017/02/17/scala-01/">


<meta name="description" content="简述文章是对最近正在学习的 scala 的一些总结，因为 scala 语法相比于传统编程语言有点变化太大了，所以为了更透彻的了解这些语法的特性，很多 scala 语法，我会在这一系列的 scala 学习文章中尝试把 scala 字节码翻译到 java 语言，以此来加深理解。 大概计划是 10 篇左右的文章，不知道啥时候能写完。 变量声明val 声明常量,后续可以使用无法修改常量指向 val xxx">
<meta name="keywords" content="scala">
<meta property="og:type" content="article">
<meta property="og:title" content="scala 学习 01 基本语法">
<meta property="og:url" content="http://acyouzi.com/2017/02/17/scala-01/index.html">
<meta property="og:site_name" content="acyouzi">
<meta property="og:description" content="简述文章是对最近正在学习的 scala 的一些总结，因为 scala 语法相比于传统编程语言有点变化太大了，所以为了更透彻的了解这些语法的特性，很多 scala 语法，我会在这一系列的 scala 学习文章中尝试把 scala 字节码翻译到 java 语言，以此来加深理解。 大概计划是 10 篇左右的文章，不知道啥时候能写完。 变量声明val 声明常量,后续可以使用无法修改常量指向 val xxx">
<meta property="og:locale" content="zh">
<meta property="og:updated_time" content="2019-08-07T13:57:52.006Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="scala 学习 01 基本语法">
<meta name="twitter:description" content="简述文章是对最近正在学习的 scala 的一些总结，因为 scala 语法相比于传统编程语言有点变化太大了，所以为了更透彻的了解这些语法的特性，很多 scala 语法，我会在这一系列的 scala 学习文章中尝试把 scala 字节码翻译到 java 语言，以此来加深理解。 大概计划是 10 篇左右的文章，不知道啥时候能写完。 变量声明val 声明常量,后续可以使用无法修改常量指向 val xxx">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1">
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d310e8dddd6fde3a70c9b10c17107ae3";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-89126170-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-89126170-1');
  </script>


  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-4100561021751428",
      enable_page_level_ads: true
    });
  </script>



    <title> scala 学习 01 基本语法 - acyouzi </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">acyouzi</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          scala 学习 01 基本语法
        
      </h1>

      <time class="post-time">
          Feb 17 2017
      </time>
    </header>
    
            <div class="post-content">
            <h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>文章是对最近正在学习的 scala 的一些总结，因为 scala 语法相比于传统编程语言有点变化太大了，所以为了更透彻的了解这些语法的特性，很多 scala 语法，我会在这一系列的 scala 学习文章中尝试把 scala 字节码翻译到 java 语言，以此来加深理解。</p>
<p>大概计划是 10 篇左右的文章，不知道啥时候能写完。</p>
<h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>val 声明常量,后续可以使用无法修改常量指向</p>
<pre><code>val xxx = xxx</code></pre><p>var 声明变量，可以改变其引用</p>
<pre><code>var xxx = xxx</code></pre><p>scala 中建议使用 val.</p>
<p>指定变量类型</p>
<pre><code>val name: String = xxx
val name: Any = xx</code></pre><p>如果是在方法体内部声明的局部变量，对应到 java 里面就是 java 的局部变量，val 与 var 在 java 代码上看来并没有什么不同</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><pre><code>Byte,Char,Short,Int,Long,Float,Double,Boolean</code></pre><p>scala 使用加强类对类的功能进行加强，如 StringOps, RichInt, RichDouble 等，scala 中的操作符 (+/-/*/&amp;/||/!…) 都是函数。</p>
<p>注意 scala 中没有 ++ – 方法</p>
<p>scala 中函数调用如果不需要传递参数，scala 允许调用时省略括号。</p>
<h2 id="条件与循环"><a href="#条件与循环" class="headerlink" title="条件与循环"></a>条件与循环</h2><p>if 表达式有值，就是 if 或者 else 最后一行语句的执行值。</p>
<pre><code>val i = if(age &gt; 30) 1 else 0 // 返回 1 或者 0</code></pre><p>这个放到 java 中会被翻译成三元表达式，if 表达式可以自动推断类型。</p>
<pre><code>val j = if (i &lt; 5 ) 0 else &quot;Test&quot;</code></pre><p>上面这个表达式的值是 Any 类型，也就是 java 的 object </p>
<pre><code>Object j = i &lt; 5?BoxesRunTime.boxToInteger(0):&quot;Test&quot;;</code></pre><p>当然如果希望在 if else 语句中执行多句话，也可以使用 {}</p>
<pre><code>val j = if (i &lt; 5 ) {
  println(&quot;oo1&quot;)
  1
}else{
  println(&quot;oo2&quot;)
  2
}</code></pre><p>这样的语句就对应 java 中正常的 if else 表达式了。</p>
<pre><code>byte var10000;
if(i &lt; 5) {
  .MODULE$.println(&quot;oo1&quot;);
  var10000 = 1;
} else {
  .MODULE$.println(&quot;oo2&quot;);
  var10000 = 2;
}
// 赋值语句在最后
byte j = var10000;</code></pre><p>只有 if 的没有 else 的表达式对应到java 中也需要出现 else 语句块，else 的返回值为 UNIT 类型。</p>
<pre><code>// scala 
val j = if (i &lt; 5 ) {
  println(&quot;oo1&quot;)
  1
}
// java
if(i &lt; 5) {
  .MODULE$.println(&quot;oo1&quot;);
  var10000 = BoxesRunTime.boxToInteger(1);
} else {
  var10000 = BoxedUnit.UNIT;
}
Object j = var10000;</code></pre><p>while 表达式还是跟老样子，但是有一点不同的是，条件里边只能放 boolean 类型，不会再把 int(0) 当做 false 了。</p>
<pre><code>var i = 10
while ( i != 0 ){
  i -= 1
  print(&quot;Test&quot;)
}</code></pre><p>for 语句是不再是 java 中 for 语句的样式。对应到 java 中是一个 foreach 函数。  </p>
<pre><code>// scala 
for (i &lt;- 1 to 10 ) println(i)

// java
.MODULE$.to$extension0(scala.Predef..MODULE$.intWrapper(1), 10).foreach$mVc$sp((i) -&gt; {
  scala.Predef..MODULE$.print(BoxesRunTime.boxToInteger(i - 1));
});</code></pre><p>多重循环，对应到 java 里边就是两个 lambda 外边是 i 里边是 j </p>
<pre><code>for(i &lt;- 1 to 9; j &lt;- 1 to 9) {
  if(j == i) {
    println(i * j)
  } else if (i &gt; j){
    print(i * j + &quot; &quot;)
  }
}
// java 代码，如果直接反编译看到的代码会引用很多自定义的类
// 这里给出的是 java lambda 表达式的模拟实现
Stream.iterate(1, i -&gt; i + 1).limit(9).forEach(i -&gt; {
  Stream.iterate(1, j -&gt; j + 1).limit(9).forEach(j -&gt; {
    if (i == j) {
      System.out.println(i * j);
    } else if (i &gt; j) {
      System.out.print(i * j + &quot; &quot;);
    }
  });
});</code></pre><p>if 守卫 的使用</p>
<pre><code>// scala 
for(i &lt;- 1 to 100 if i % 2 == 0) println(i)

// 对应到 java 中就是在 stream 中多了一个 filter
Stream.iterate(1, i -&gt; i + 1).limit(100).filter(i -&gt; {
  return i % 2 == 0;
}).forEach(i -&gt; {
  System.out.println(i);
});</code></pre><p>yield 的使用</p>
<pre><code>// 用于构造集合
val list = for(i &lt;- 1 to 100 if i % 2 == 0) yield i;

// java 实现
Stream.iterate(1, i -&gt; i + 1).limit(100).filter(i -&gt; {
  return i % 2 == 0;
}).map(i -&gt; {
  return i;
}).collect(Collectors.toList());</code></pre><h2 id="控制台读写"><a href="#控制台读写" class="headerlink" title="控制台读写"></a>控制台读写</h2><p>写：print,println,printf</p>
<p>读: scala.io.StdIn.readXxx 的一系列方法。</p>
<h2 id="函数相关"><a href="#函数相关" class="headerlink" title="函数相关"></a>函数相关</h2><p>使用 def 定义。必须给出所有参数的类型，但是不一定给出函数返回值的类型，只要右侧的函数体中不包含递归的语句，Scala就可以自己根据右侧的表达式推断出返回类型。</p>
<p>如果是递归函数需要明确给出返回值类型。单行函数，可以不使用 {}。</p>
<pre><code>def Func_Name([var_name: var_Type[,...]]) [[: return_Type] =] {
    // 函数体
} </code></pre><p>例如 </p>
<pre><code>def fab(n: Int): Int = {
  if(n &lt;= 1) 1
  else fab(n - 1) + fab(n - 2)
}</code></pre><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>直接在参数声明后面 = “xxx”</p>
<pre><code>def Func_Name(var_name: var_Type = &quot;xxxx&quot;){
    // 函数体
} </code></pre><h3 id="带名参数调用"><a href="#带名参数调用" class="headerlink" title="带名参数调用"></a>带名参数调用</h3><p>在调用时不按参数声明顺序，而是采取 var_name=”xxx” 的形式调用,示例：</p>
<pre><code>// scala 
  def func(i :Int,j: String = &quot;test&quot;,k: Boolean): Unit ={
    println(s&quot;$i --- $j ---- $k&quot;)
  }
  def main(args: Array[String]): Unit = {
    func(k=false,i = 100)
  }

// java 
  public void func(int i, String j, boolean k) {
    .MODULE$.println((new StringContext(.MODULE$.wrapRefArray((Object[])(new String[]{&quot;&quot;, &quot; --- &quot;, &quot; ---- &quot;, &quot;&quot;})))).s(.MODULE$.genericWrapArray(new Object[]{BoxesRunTime.boxToInteger(i), j, BoxesRunTime.boxToBoolean(k)})));
  }
  public String func$default$2() {
    return &quot;test&quot;;
  }
  public void main(String[] args) {
    boolean x$1 = false;
    byte x$2 = 100;
    String x$3 = this.func$default$2();
    this.func(x$2, x$3, x$1);
  }</code></pre><p>通过上面的例子可以得出结论，这些玩意要是出现在 js 里面那就是被人吐槽的语法糖啊：</p>
<ol>
<li>默认参数不限制使用在参数列表的哪个位置，默认参数后面可以继续跟非默认参数，这点不同于常见的非默认参数</li>
<li>带名参数调用，未带名参数必须在最前边, 在使用带名参数时默认参数仍然有效。</li>
<li>默认参数翻译到 java 中保存在一个函数中，函数名是 funcname$default$index()</li>
<li>带名参数，实际上是在编译的时候根据参数名对参数位置进行了调整。</li>
</ol>
<h3 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h3><pre><code>def sum(nums: Int*) = {
  //
}</code></pre><p>实际上就是一个 seq 对象。</p>
<pre><code>public int sum(Seq&lt;Object&gt; nums) {
  // 
}</code></pre><p>所以在调用时可以 sum(1,2,3,4) 这样调用，如果有一个已经定义好的数组，必须的转换为 Seq 才能传入</p>
<pre><code>sum((1 to 10):_*)</code></pre><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>就是没有返回值的函数。定义函数时，如果函数体直接包裹在了花括号里面，而没有使用=连接，则函数的返回值类型就是Unit。这样的函数就被称之为过程。过程通常用于不需要返回值的函数，过程还有一种写法，就是将函数的返回值类型定义为Unit。</p>
<pre><code>def func2(i: Int){i}
def func3(i: Int):Unit={i}</code></pre><p>这些函数在 java 中的返回值会被设置为 void.</p>
<h3 id="lazy-值"><a href="#lazy-值" class="headerlink" title="lazy 值"></a>lazy 值</h3><p>如果将一个变量声明为lazy，则只有在第一次使用该变量时，变量对应的表达式才会发生计算。实际上就是搞了个函数。</p>
<pre><code>lazy val i = 10*10</code></pre><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>类似 java ，但是不特别区分受检查异常，因为很多触发异常的问题是无法在 catch 中解决的，所以有设计思想认为检查型异常非常不好，起不到实际作用但是增加了代码了冗余。</p>
<pre><code>try{
  throw new Exception(&quot;&quot;)
}catch {
  case e: Exception =&gt; println(e)
}finally {
  println(&quot;finally&quot;);
}</code></pre><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>scala 中的包和 java 中的包作用相同，同一个包可以定义在多个文件中，相关语法如下</p>
<pre><code>package com{
  package acyouzi{
    package scala{
      class Test{
        // do ...
      }
    }
  }
}</code></pre><p>包声明还可以写作串联式</p>
<pre><code>package com.acyouzi.test{
  class Person{
    // ...
  }
}</code></pre><p>或者像 java 一样进行文件顶部标记</p>
<h2 id="包对象"><a href="#包对象" class="headerlink" title="包对象"></a>包对象</h2><p>包可以包含类，对象和 trait,但是如果我们希望添加一个工具函数，比较合理的做法是放到一个包下面，而不是添加到某个工具类中，这就是包对象的用途。</p>
<p>每个包都可以有一个包对象，需要在父包中定义它，并且名称与子包一样。</p>
<pre><code>package com.acyouzi
package object scala {
  val xxx = &quot;test&quot;
}</code></pre><p>这样就能在整个包中直接使用包对象中定义东西了</p>
<h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><p>scala import 使用 * 作为通配符</p>
<pre><code>// 引入具体类
import com.acyouzi.scala
// 引入包下的全部类
import com.acyouzi._
// 引入类中的成员
import com.acyouzi.scala._
// 引入多个类
import com.acyouzi.{Test1,Test2}
// 重命名某个引入的类
import com.acyouzi.{Test1 =&gt; Test}
// 隐藏包下的某个类
import com.acyouzi.{Test1 =&gt; _,_}</code></pre><h2 id="隐式引入"><a href="#隐式引入" class="headerlink" title="隐式引入"></a>隐式引入</h2><p>这三个包是默认引入的包：</p>
<pre><code>java.lang._
scala._
Predef._</code></pre><h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><pre><code>val source = Source.fromFile(&quot;test.txt&quot;,&quot;UTF-8&quot;)
// 按行读取
val lineiterator = source.getLines()
for (l &lt;- lineiterator){
  println(l)
}
// 读取到一个数组里面
val lines = source.getLines.toArray
// 一次全部读取
val content = source.mkString</code></pre><h2 id="从-URL-读取"><a href="#从-URL-读取" class="headerlink" title="从 URL 读取"></a>从 URL 读取</h2><pre><code>val source = Source.fromURL(&quot;http://www.acyouzi.com&quot;,&quot;UTF-8&quot;)
println(source.mkString)</code></pre><h2 id="调用-shell"><a href="#调用-shell" class="headerlink" title="调用 shell"></a>调用 shell</h2><p>需要导入相关包 import sys.process._</p>
<p>执行命令，结果打印到标准输出，然后执行是否成功(0,1)</p>
<pre><code>&quot;ls -al ~&quot; !</code></pre><p>执行命令，返回输出结果( 两个感叹号 )</p>
<pre><code>&quot;ls -al ~&quot; !!</code></pre><p>管道使用</p>
<pre><code>&quot;ls -al ~&quot; #| &quot;grep test&quot; !</code></pre><p>输入输出流重定向</p>
<pre><code>&quot;ls -al ~&quot; #&gt; new File(&quot;output.txt&quot;)
&quot;ls -al ~&quot; #&gt;&gt; new File(&quot;output.txt&quot;)
&quot;grep xxx&quot; #&lt; new URL(&quot;http://xxx&quot;)</code></pre><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><pre><code>// 生成 pattern
var pattern = &quot;[0-9]+&quot;.r
// 当存在反斜杠时最好使用原始字符串语法，不需要对反斜杠进行转义
var pattern = &quot;&quot;&quot;[0-9]+&quot;&quot;&quot;.r  

// pattern 的常用方法
pattern.findAllIn()
pattern.findFirstIn()
pattern.replaceAllIn()
pattern.replaceFirstIn()</code></pre><h2 id="正则表达式组"><a href="#正则表达式组" class="headerlink" title="正则表达式组"></a>正则表达式组</h2><p>把子表达式用括号括起来</p>
<pre><code>val pattern = &quot;&quot;&quot;([0-9]+) ([a-z]+)&quot;&quot;&quot;.r
for( pattern(num,str) &lt;- pattern.findAllIn(&quot;999 hello, 666 test&quot;)){
  println(s&quot;$num   $str&quot;)
}</code></pre><h2 id="拉链操作"><a href="#拉链操作" class="headerlink" title="拉链操作"></a>拉链操作</h2><pre><code>val a1 = Array(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
val a2 = Array(1, 2, 3)
val map = a1.zip(a2)
println(map.mkString(&quot;--&quot;))

// 输出
(a,1)--(b,2)--(c,3)</code></pre><h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><p>在 scala 存在 tuple1 - tuple22 这22个 tuple 对象，分别对应着含有 1 -22 个参数的 tuple. </p>
<pre><code>var t = (&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)
// 访问 tuple 元素
println(t._1)</code></pre><h2 id="与-Java-集合互操作"><a href="#与-Java-集合互操作" class="headerlink" title="与 Java 集合互操作"></a>与 Java 集合互操作</h2><p>scala 提供了很多集合隐式转换函数，通过引入相关隐式转换，能够简单的实现 java 集合和 scala 集合之间的相互转换。相关隐式转换函数在 scala.collection.JavaConverters 里面。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/scala/">scala</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2017/02/20/scala-02/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">scala 学习 02 类基础</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2017/02/17/maven-encyclopedia/">
        <span class="next-text nav-default">Maven 配置使用以及常用插件总结</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2016 -
    
    2019
    <span class="footer-author">acyouzi.</span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
